[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Text",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "Action",
        "importPath": "rasa_sdk",
        "description": "rasa_sdk",
        "isExtraImport": true,
        "detail": "rasa_sdk",
        "documentation": {}
    },
    {
        "label": "SlotSet",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "FollowupAction",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "UserUtteranceReverted",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "ActiveLoop",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "SlotSet",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "EventType",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "Restarted",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "AllSlotsReset",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "SlotSet",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "ConversationPaused",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "ConversationResumed",
        "importPath": "rasa_sdk.events",
        "description": "rasa_sdk.events",
        "isExtraImport": true,
        "detail": "rasa_sdk.events",
        "documentation": {}
    },
    {
        "label": "CollectingDispatcher",
        "importPath": "rasa_sdk.executor",
        "description": "rasa_sdk.executor",
        "isExtraImport": true,
        "detail": "rasa_sdk.executor",
        "documentation": {}
    },
    {
        "label": "Tracker",
        "importPath": "rasa_sdk.interfaces",
        "description": "rasa_sdk.interfaces",
        "isExtraImport": true,
        "detail": "rasa_sdk.interfaces",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "urllib3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib3",
        "description": "urllib3",
        "detail": "urllib3",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "FormValidationAction",
        "importPath": "rasa_sdk.forms",
        "description": "rasa_sdk.forms",
        "isExtraImport": true,
        "detail": "rasa_sdk.forms",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "DomainDict",
        "importPath": "rasa_sdk.types",
        "description": "rasa_sdk.types",
        "isExtraImport": true,
        "detail": "rasa_sdk.types",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "normalize",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "normalize",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "PyPDFLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "UnstructuredPDFLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "Docx2txtLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "TextLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "CSVLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "UnstructuredExcelLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "UnstructuredPowerPointLoader",
        "importPath": "langchain_community.document_loaders",
        "description": "langchain_community.document_loaders",
        "isExtraImport": true,
        "detail": "langchain_community.document_loaders",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "OpenAIEmbeddings",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "ChatOpenAI",
        "importPath": "langchain_openai",
        "description": "langchain_openai",
        "isExtraImport": true,
        "detail": "langchain_openai",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain_community.vectorstores",
        "description": "langchain_community.vectorstores",
        "isExtraImport": true,
        "detail": "langchain_community.vectorstores",
        "documentation": {}
    },
    {
        "label": "FAISS",
        "importPath": "langchain_community.vectorstores",
        "description": "langchain_community.vectorstores",
        "isExtraImport": true,
        "detail": "langchain_community.vectorstores",
        "documentation": {}
    },
    {
        "label": "RecursiveCharacterTextSplitter",
        "importPath": "langchain.text_splitter",
        "description": "langchain.text_splitter",
        "isExtraImport": true,
        "detail": "langchain.text_splitter",
        "documentation": {}
    },
    {
        "label": "chardet",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "chardet",
        "description": "chardet",
        "detail": "chardet",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "ActionSetDataProtectionAccepted",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionSetDataProtectionAccepted(Action):\n    def name(self) -> Text:\n        return \"action_set_data_protection_accepted\"\n    async def run(self, dispatcher: CollectingDispatcher,\n                  tracker: Tracker,\n                  domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        intent = tracker.latest_message['intent'].get('name')\n        # Determine status based on intent\n        if intent == \"accept_data_protection\":\n            status = \"true\"",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionExtractAndCheckToken",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionExtractAndCheckToken(Action):\n    def name(self) -> Text:\n        return \"action_extract_and_check_token\"\n    def run(\n        self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]\n    ) -> List[Dict[Text, Any]]:\n        try:\n            # Safely extract metadata\n            metadata = tracker.latest_message.get(\"metadata\", {}) or {}\n            # Extract and validate token",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateProvideUserDetailsForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateProvideUserDetailsForm(FormValidationAction):\n    def name(self) -> str:\n        return \"validate_provide_user_details_form\"\n    async def validate_name(\n        self, slot_value: str, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict\n    ) -> Dict[str, str]:\n        \"\"\"Ensure the bot correctly handles full names.\"\"\"\n        if not slot_value or not slot_value.strip():\n            dispatcher.utter_message(text=\"Por favor, proporcione su nombre y apellido.\")\n            return {\"name\": None}",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionAnswerWithRAG",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionAnswerWithRAG(Action):\n    def name(self) -> Text:\n        return \"action_answer_with_rag\"\n    def run(\n        self,\n        dispatcher,\n        tracker,\n        domain\n    ) -> List[Dict[Text, Any]]:\n        user_query = tracker.latest_message.get('text', '').strip()",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionCheckSatisfaction",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionCheckSatisfaction(Action):\n    def name(self) -> Text:\n        return \"action_check_satisfaction\"\n    async def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        logging.info(\"Prompting the user for satisfaction feedback.\")\n        dispatcher.utter_message(\n            text=\"¿Está satisfecho con el servicio proporcionado?\",\n            buttons=[\n                {\"title\": \"Satisfecho\", \"payload\": '/satisfaction{\"satisfied\": \"true\"}'},\n                {\"title\": \"No satisfecho\", \"payload\": '/satisfaction{\"satisfied\": \"false\"}'}",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionHandleSatisfaction",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionHandleSatisfaction(Action):\n    def name(self) -> Text:\n        return \"action_handle_satisfaction\"\n    async def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        satisfaction = tracker.get_slot(\"satisfied\")\n        logging.info(f\"User satisfaction received: {satisfaction}\")\n        if satisfaction == \"true\":\n            # dispatcher.utter_message(text=\"Gracias por sus comentarios. Procedamos a la encuesta de satisfacción.\")\n            return [SlotSet(\"inquiry_resolved\", True), ActiveLoop(\"feedback_survey_form\")]\n        elif satisfaction == \"false\":",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateFeedbackSurveyForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateFeedbackSurveyForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_feedback_survey_form\"\n    async def validate_ease_of_finding(self, slot_value: Any, tracker: Tracker) -> Dict[str, Any]:\n        user_id = tracker.sender_id\n        logger.info(f\"Survey - Ease of Finding: User {user_id} rated {slot_value}\")\n        return {\"ease_of_finding\": slot_value.split(\" \")[0]}  # Store as integer only\n    async def validate_formats_provided(self, slot_value: Any, tracker: Tracker) -> Dict[str, Any]:\n        user_id = tracker.sender_id\n        logger.info(f\"Survey - Formats Provided: User {user_id} rated {slot_value}\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionRedirectToCollectionCenter",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionRedirectToCollectionCenter(Action):\n    def name(self) -> Text:\n        return \"action_redirect_to_collection_center\"\n    async def run(\n        self, \n        dispatcher: CollectingDispatcher, \n        tracker: Tracker, \n        domain: Dict[Text, Any]\n    ) -> List[Dict[Text, Any]]:\n        logging.info(\"Redirecting user to the Collection Service Center.\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionEndConversation",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionEndConversation(Action):\n    def name(self) -> Text:\n        return \"action_end_conversation\"\n    async def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        dispatcher.utter_message(text=\"¡Fue un placer asistirle!\")\n        return []\n###########Claims Custom Actions#################################\n# Flexible email validation regex\nEMAIL_REGEX = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\n# OTP validation regex (ensures a 6-digit numerical OTP)",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateUserLoginForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateUserLoginForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_user_login_form\"\n    def validate_user_email(\n        self,\n        slot_value: Any,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any]\n    ) -> Dict[Text, Any]:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateUserForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateUserForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_user_registration_form\"\n    def make_api_request(self, url: str, method: str = \"GET\", headers: Dict[str, str] = None, data: Dict = None, retries: int = 3, delay: int = 5) -> Dict:\n        \"\"\"\n        Makes an API request with retry logic for handling 503 errors.\n        Retries up to `retries` times before giving up.\n        \"\"\"\n        for attempt in range(retries):\n            try:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidatePhoneNumberForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidatePhoneNumberForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_phone_number_form\"\n    # Validate the phone number provided by the user\n    async def validate_phone_number(\n        self,\n        value: Text,  # The value entered by the user\n        dispatcher: CollectingDispatcher,  # Used to send messages to the user\n        tracker: Tracker,  # Tracks the state of the conversation\n        domain: Dict[Text, Any],  # Domain configuration for the bot",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateVerifyEmailForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateVerifyEmailForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_verify_email_form\"\n    def validate_new_user_email(\n        self,\n        value: Text,  # The email address entered by the user\n        dispatcher: CollectingDispatcher,  # Used to send messages to the user\n        tracker: Tracker,  # Tracks the state of the conversation\n        domain: Dict[Text, Any],  # Domain configuration for the bot\n    ) -> Optional[Dict[Text, Any]]:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "RegisterUser",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class RegisterUser(Action):\n    def name(self) -> str:\n        return \"action_register_user\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: DomainDict):\n        # Gather all required user information from slots\n        national_id = tracker.get_slot(\"new_user_national_id\")  # User's national identification number\n        fingerprint = tracker.get_slot(\"new_user_fingerprint\")  # User's fingerprint data\n        email = tracker.get_slot(\"new_user_email\")  # User's email address\n        otp = tracker.get_slot(\"new_user_otp\")  # OTP code provided by the user\n        mobile_number = tracker.get_slot(\"phone_number\")  # User's mobile phone number",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchBasicUserInfo",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchBasicUserInfo(Action):\n    def name(self) -> Text:\n        return \"action_fetch_basic_user_info\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Endpoint URL to fetch user account details\n        url = f\"{USER_BASE_URL}/api/v1/account\"\n        logger.info(\"Fetching user basic information from URL: %s\", url)\n        # Retrieve the authorization token from the tracker slots\n        auth_token = tracker.get_slot(\"id_token\")\n        if not auth_token:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionHandleProvinceAndCanton",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionHandleProvinceAndCanton(Action):\n    def name(self) -> Text:\n        return \"action_handle_province_and_canton\"\n    async def run(self, dispatcher: CollectingDispatcher,\n                  tracker: Tracker,\n                  domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Base URLs\n        api_url_provinces = f\"{ADMIN_BASE_URL}/api/v1/provinces/dropdown-list\"\n        selected_province = tracker.get_slot(\"province\")\n        selected_province_id = tracker.get_slot(\"province_id\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchAndSelectPriorityCareGroupOptions",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchAndSelectPriorityCareGroupOptions(Action):\n    def name(self) -> str:\n        return \"action_fetch_and_select_priority_care_group_options\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: dict) -> list:\n        url = f\"{TICKET_BASE_URL}/api/v1/masters\"\n        logger.info(\"Fetching priority care group information from URL: %s\", url)\n        # Retrieve the authorization token from the tracker slots\n        auth_token = tracker.get_slot(\"id_token\")\n        if not auth_token:\n            logger.error(\"Authorization token is missing in slot.\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchAndSelectCustomerTypeOptions",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchAndSelectCustomerTypeOptions(Action):\n    def name(self) -> str:\n        return \"action_fetch_and_select_customer_type_options\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: dict) -> list:\n        url = f\"{TICKET_BASE_URL}/api/v1/masters\"\n        logger.info(\"Fetching customer type information from URL: %s\", url)\n        # Retrieve the authorization token from the tracker slots\n        auth_token = tracker.get_slot(\"id_token\")\n        if not auth_token:\n            logger.error(\"Authorization token is missing in slot.\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchOrganizationList",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchOrganizationList(Action):\n    def name(self) -> Text:\n        return \"action_fetch_organization_list\"\n    def run(self, dispatcher, tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Construct the API endpoint URL\n        url = f\"{USER_BASE_URL}/api/v1/masters/organization-list\"\n        logger.info(\"Fetching organization list from URL: %s\", url)\n        # Retrieve the authorization token from the tracker slots\n        auth_token = tracker.get_slot(\"id_token\")\n        if not auth_token:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionSelectOrganization",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionSelectOrganization(Action):\n    def name(self) -> Text:\n        return \"action_select_organization\"\n    def run(self, dispatcher, tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Retrieve the stored organization map and the user's selection index\n        organization_map = tracker.get_slot(\"organization_map\")\n        selected_entity_index = tracker.get_slot(\"organization_selection\")\n        logger.info(\"Selected organization index: %s\", selected_entity_index)\n        # Validate if the organization map and selection index exist\n        if not organization_map or not selected_entity_index:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionHandleClaim",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionHandleClaim(Action):\n    def name(self) -> Text:\n        return \"action_handle_claim\"\n    async def run(self, dispatcher: CollectingDispatcher,\n                  tracker: Tracker,\n                  domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Fetch the base URL from environment variables with a fallback value\n        USER_BASE_URL = os.getenv(\"USER_BASE_URL\", \"${USER_BASE_URL}\")\n        auth_token = tracker.get_slot(\"id_token\")\n        # Check for missing authorization token",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionSetFileUploadRequired",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionSetFileUploadRequired(Action):\n    def name(self) -> Text:\n        return \"action_handle_file_upload\"\n    def run(\n        self, \n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any]\n    ) -> List[Dict[Text, Any]]:\n        intent = tracker.latest_message['intent'].get('name')",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateTestForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateTestForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_claim_form\"\n    def validate_antecedentes(\n        self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]\n    ) -> Dict[Text, Any]:\n        # Validate antecedentes\n        if len(slot_value) == 0:\n            logger.error(\"Validation error: antecedentes cannot be empty.\")\n            dispatcher.utter_message(",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionSubmitClaimDetails",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionSubmitClaimDetails(Action):\n    def name(self) -> Text:\n        return \"action_submit_claim_details\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        try:\n            # Retrieve slot values\n            antecedentes = tracker.get_slot(\"antecedentes\")\n            peticion_especifica = tracker.get_slot(\"peticion_especifica\")\n            logger.info(\"Fetching slots in action_submit_claim_details\")\n            logger.debug(f\"antecedentes: {antecedentes}\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateUserAgreeClaimForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateUserAgreeClaimForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_user_agree_claim_form\"\n    def validate_accept_terms(\n        self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]\n    ) -> Dict[Text, Any]:\n        if slot_value is True:\n            logger.info(\"User accepted the terms and conditions.\")\n            return {\"accept_terms\": slot_value}\n        else:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFileClaim",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFileClaim(Action):\n    def name(self) -> Text:\n        return \"action_file_claim\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Log initial slot values for debugging purposes\n        logger.info(f\"Tracker slots (before processing): {tracker.current_slot_values()}\")\n        logger.info(\"Collecting claim details from slots.\")\n        # Extract claim details from slots prefixed with 'claim_'\n        identificacion = tracker.get_slot(\"claim_national_id\")\n        email = tracker.get_slot(\"claim_email\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionProceedWithClaim",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionProceedWithClaim(Action):\n    def name(self) -> Text:\n        return \"action_proceed_with_claim\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Log the intent to proceed\n        logger.info(\"User opted to proceed with filing the claim.\")\n        # Retrieve all slots\n        form_data = {\n            'identificacion': tracker.get_slot(\"claim_national_id\"),\n            'email': tracker.get_slot(\"claim_email\"),",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchTickets",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchTickets(Action):\n    def name(self) -> Text:\n        return \"action_fetch_tickets\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: Tracker,\n            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Log current slot values before processing\n        logger.info(f\"Tracker slots (before fetching tickets): {tracker.current_slot_values()}\")\n        # Retrieve authentication token from tracker slots\n        auth_token = tracker.get_slot(\"id_token\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchClaimReference",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchClaimReference(Action):\n    def name(self) -> Text:\n        return \"action_fetch_claim_reference\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: Tracker,\n            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Log current slot values before processing\n        logger.info(f\"Tracker slots (before fetching claim reference): {tracker.current_slot_values()}\")\n        # Retrieve authentication token and selected ticket ID from tracker slots\n        auth_token = tracker.get_slot(\"id_token\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateSecondInstanceClaimCommentsForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateSecondInstanceClaimCommentsForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_second_instance_claim_comments_form\"\n    def validate_second_instance_claim_comments(\n        self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]\n    ) -> Dict[Text, Any]:\n        if not isinstance(slot_value, str):\n            dispatcher.utter_message(text=\"El comentario debe ser un texto válido. Inténtelo de nuevo\")\n            return {\"second_instance_claim_comments\": None}\n        if len(slot_value.strip()) == 0:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFileSecondInstance",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFileSecondInstance(Action):\n    def name(self) -> Text:\n        return \"action_file_second_instance\"\n    async def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        logger.info(f\"Tracker slots: {tracker.current_slot_values()}\")\n        # Extract required slots\n        auth_token = tracker.get_slot(\"id_token\")\n        claim_reference_id = tracker.get_slot(\"claim_reference_id\")\n        second_instance_comment = tracker.get_slot(\"second_instance_claim_comments\")\n        # Extract attachments by filtering keys starting with 'attachmentsIds'",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchComplaintTickets",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchComplaintTickets(Action):\n    def name(self) -> Text:\n        return \"action_fetch_complaint_tickets\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: Tracker,\n            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Log current slot values before processing\n        logger.info(f\"Tracker slots (before fetching complaint tickets): {tracker.current_slot_values()}\")\n        # Retrieve authentication token from tracker slots\n        auth_token = tracker.get_slot(\"id_token\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchComplaintReference",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchComplaintReference(Action):\n    def name(self) -> Text:\n        return \"action_fetch_complaint_reference\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: Tracker,\n            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Log current slot values before processing\n        logger.info(f\"Tracker slots (before fetching complaint reference): {tracker.current_slot_values()}\")\n        # Retrieve authentication token and selected ticket ID from tracker slots\n        auth_token = tracker.get_slot(\"id_token\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ValidateClaimDetailsForm",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ValidateClaimDetailsForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_complaint_details_form\"\n    def validate_complaint_antecedentes(\n        self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]\n    ) -> Dict[Text, Any]:\n        # Validate antecedentes\n        if not slot_value.strip():\n            logger.error(\"Validation error: complaint_antecedentes cannot be empty.\")\n            dispatcher.utter_message(",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "FileComplaint",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class FileComplaint(Action):\n    def name(self) -> Text:\n        return \"action_file_complaint\"\n    async def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict]:\n        # Extract required slots\n        auth_token = tracker.get_slot(\"id_token\")\n        complaint_reference_id = tracker.get_slot(\"complaint_reference_id\")\n        specific_petition = tracker.get_slot(\"complaint_peticion_especifica\")\n        precedents = tracker.get_slot(\"complaint_antecedentes\")\n        # Extract attachments by filtering keys starting with 'attachmentsIds'",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchTicketIds",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchTicketIds(Action):\n    def name(self) -> Text:\n        # Name of the action to fetch ticket IDs\n        return \"action_fetch_ticket_ids_status\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        id_token = tracker.get_slot(\"id_token\")\n        if not id_token:\n            dispatcher.utter_message(text=\"El código de autenticación falta. Por favor, inicie sesión nuevamente\")\n            return []\n        headers = {\"Authorization\": f\"Bearer {id_token}\"}  # Authorization header",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchTicketDetails",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchTicketDetails(Action):\n    def name(self) -> Text:\n        return \"action_show_ticket_details_status\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        \"\"\"\n        Fetches ticket details based on the given ticket ID and returns them in formatted JSON.\n        The ticket status is translated from English to Spanish before being displayed.\n        \"\"\"\n        # Retrieve the authentication token and ticket ID from the tracker\n        id_token = tracker.get_slot(\"id_token\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionHandleFallback",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionHandleFallback(Action):\n    def name(self) -> str:\n        return \"action_handle_fallback\"\n    def run(self, dispatcher: CollectingDispatcher, tracker, domain: dict) -> list:\n        user_message = tracker.latest_message.get('text')\n        fallback_count = tracker.get_slot('fallback_count') or 0\n        previous_message = tracker.events[-2].get('text') if len(tracker.events) > 1 else None\n        # Log the unrecognized input for analysis\n        logger.warning(f\"Unrecognized input: {user_message}\")\n        logger.info(f\"Fallback count: {fallback_count}\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionDefaultFallback",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionDefaultFallback(Action):\n    def name(self) -> Text:\n        return \"action_default_fallback\"\n    def run(self, dispatcher, tracker, domain) -> List[Dict[Text, Any]]:\n        fallback_count = tracker.get_slot(\"fallback_count\") or 0\n        fallback_count += 1\n        logger.info(f\"ActionDefaultFallback triggered. Current fallback count: {fallback_count}\")\n        if fallback_count >= 3:  # Limit to 3 fallback occurrences\n            dispatcher.utter_message(\n                text=\"Parece que no estamos entendiendo. Por favor, reformula tu pregunta o intenta algo diferente.\"",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionResetAllSlotsExceptToken",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionResetAllSlotsExceptToken(Action):\n    def name(self) -> Text:\n        return \"action_reset_all_slots_except_token\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: Tracker,\n            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Get all slots except 'id_token'\n        all_slots = tracker.slots.keys()\n        slots_to_reset = [slot for slot in all_slots if slot != \"id_token\"]\n        logger.info(f\"Resetting all slots except 'id_token': {slots_to_reset}\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionResetAllSlots",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionResetAllSlots(Action):\n    def name(self) -> Text:\n        return \"action_reset_all_slots\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: Tracker,\n            domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        # Get all slots from the domain\n        all_slots = tracker.slots.keys()\n        logger.info(f\"Resetting all slots: {list(all_slots)}\")\n        # Reset all slots by setting their values to None",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionSetEndOfJourneyFalse",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionSetEndOfJourneyFalse(Action):\n    def name(self) -> Text:\n        return \"action_set_end_of_journey_false\"\n    def run(self, dispatcher, tracker, domain) -> List[Dict[Text, Any]]:\n        return [SlotSet(\"end_of_journey\", False)]\nclass ActionHandoff(Action):\n    def name(self) -> str:\n        return \"action_human_agent_handoff\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # Collect conversation history",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionHandoff",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionHandoff(Action):\n    def name(self) -> str:\n        return \"action_human_agent_handoff\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[str, Any]) -> List[Dict[str, Any]]:\n        # Collect conversation history\n        conversation = []\n        for event in tracker.events:\n            if event.get(\"event\") == \"user\" and \"text\" in event:\n                conversation.append(f\"User: {event['text']}\")\n            elif event.get(\"event\") == \"bot\" and \"text\" in event:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionResumeConversation",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionResumeConversation(Action):\n    def name(self) -> str:\n        return \"action_resume_conversation\"\n    def run(self, dispatcher, tracker, domain):\n        dispatcher.utter_message(text=\"Continuando la conversación con el bot.\")\n        return [ConversationResumed()]\nclass ActionHandleMetadata(Action):\n    def name(self) -> Text:\n        return \"action_handle_metadata\"\n    def run(self, dispatcher: CollectingDispatcher,",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionHandleMetadata",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionHandleMetadata(Action):\n    def name(self) -> Text:\n        return \"action_handle_metadata\"\n    def run(self, dispatcher: CollectingDispatcher,\n            tracker: \"Tracker\",\n            domain: \"DomainDict\") -> List[Dict[Text, Any]]:\n        # Extract metadata from the latest message\n        metadata = tracker.latest_message.get(\"metadata\", {})\n        logger.info(f\"Received metadata: {metadata}\")  # Log the metadata for debugging\n        # Extract all attachment IDs by filtering keys starting with 'attachmentsIds'",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionFetchTicketIdsPdf",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionFetchTicketIdsPdf(Action):\n    def name(self) -> Text:\n        \"\"\"Defines the action name\"\"\"\n        return \"action_fetch_ticket_ids_status_pdf_download\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        \"\"\"Fetches ticket IDs for PDF download\"\"\"\n        # Retrieve user authentication token\n        id_token = tracker.get_slot(\"id_token\")\n        if not id_token:\n            logger.warning(\"No authorization token found.\")",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionDownloadPDF",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionDownloadPDF(Action):\n    def name(self) -> Text:\n        \"\"\"Defines the action name\"\"\"\n        return \"action_download_pdf\"\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        \"\"\"Handles PDF ticket download\"\"\"\n        pdf_ticket_id = tracker.get_slot(\"pdf_ticket_id\")\n        id_token = tracker.get_slot(\"id_token\")\n        # 🔴 Check if Token Exists\n        if not id_token:",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "ActionSendInquiry",
        "kind": 6,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "class ActionSendInquiry(Action):\n    def name(self) -> str:\n        return \"action_send_inquiry_datapoints\"\n    async def run(self, dispatcher, tracker, domain):\n        # Retrieve the API base URL from environment variables\n        base_url = os.getenv(\"USER_BASE_URL\")\n        if not base_url:\n            logger.error(\"USER_BASE_URL is missing in environment variables.\")\n            return []\n        # Construct the complete API endpoint URL",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "FAISS_INDEX_FILE",
        "kind": 5,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "FAISS_INDEX_FILE = \"/app/actions/faiss_index\"\n# Initialize logger\nlogger = setup_logger()\nclass ActionSetDataProtectionAccepted(Action):\n    def name(self) -> Text:\n        return \"action_set_data_protection_accepted\"\n    async def run(self, dispatcher: CollectingDispatcher,\n                  tracker: Tracker,\n                  domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        intent = tracker.latest_message['intent'].get('name')",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "logger = setup_logger()\nclass ActionSetDataProtectionAccepted(Action):\n    def name(self) -> Text:\n        return \"action_set_data_protection_accepted\"\n    async def run(self, dispatcher: CollectingDispatcher,\n                  tracker: Tracker,\n                  domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        intent = tracker.latest_message['intent'].get('name')\n        # Determine status based on intent\n        if intent == \"accept_data_protection\":",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "EMAIL_REGEX",
        "kind": 5,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "EMAIL_REGEX = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\n# OTP validation regex (ensures a 6-digit numerical OTP)\nOTP_REGEX = r'^\\d{6}$'\nclass ValidateUserLoginForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_user_login_form\"\n    def validate_user_email(\n        self,\n        slot_value: Any,\n        dispatcher: CollectingDispatcher,",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "OTP_REGEX",
        "kind": 5,
        "importPath": "chatbot.actions.actions",
        "description": "chatbot.actions.actions",
        "peekOfCode": "OTP_REGEX = r'^\\d{6}$'\nclass ValidateUserLoginForm(FormValidationAction):\n    def name(self) -> Text:\n        return \"validate_user_login_form\"\n    def validate_user_email(\n        self,\n        slot_value: Any,\n        dispatcher: CollectingDispatcher,\n        tracker: Tracker,\n        domain: Dict[Text, Any]",
        "detail": "chatbot.actions.actions",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "chatbot.actions.logger_fun",
        "description": "chatbot.actions.logger_fun",
        "peekOfCode": "def setup_logger(name=\"my_logger\"):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    if not logger.handlers:\n        # Attach FileHandler to send logs to a file\n        handler = logging.FileHandler(LOG_FILE_PATH)\n        handler.setLevel(logging.DEBUG)\n        # Define the log message format\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)",
        "detail": "chatbot.actions.logger_fun",
        "documentation": {}
    },
    {
        "label": "LOG_DIR",
        "kind": 5,
        "importPath": "chatbot.actions.logger_fun",
        "description": "chatbot.actions.logger_fun",
        "peekOfCode": "LOG_DIR = \"chatbot_logs\"\nLOG_FILE_NAME = \"chatbot.log\"\n# Ensure that the log directory exists\nif not os.path.exists(LOG_DIR):\n    os.makedirs(LOG_DIR)\nLOG_FILE_PATH = os.path.join(LOG_DIR, LOG_FILE_NAME)\n# Set up the logger with FileHandler\ndef setup_logger(name=\"my_logger\"):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)",
        "detail": "chatbot.actions.logger_fun",
        "documentation": {}
    },
    {
        "label": "LOG_FILE_NAME",
        "kind": 5,
        "importPath": "chatbot.actions.logger_fun",
        "description": "chatbot.actions.logger_fun",
        "peekOfCode": "LOG_FILE_NAME = \"chatbot.log\"\n# Ensure that the log directory exists\nif not os.path.exists(LOG_DIR):\n    os.makedirs(LOG_DIR)\nLOG_FILE_PATH = os.path.join(LOG_DIR, LOG_FILE_NAME)\n# Set up the logger with FileHandler\ndef setup_logger(name=\"my_logger\"):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    if not logger.handlers:",
        "detail": "chatbot.actions.logger_fun",
        "documentation": {}
    },
    {
        "label": "LOG_FILE_PATH",
        "kind": 5,
        "importPath": "chatbot.actions.logger_fun",
        "description": "chatbot.actions.logger_fun",
        "peekOfCode": "LOG_FILE_PATH = os.path.join(LOG_DIR, LOG_FILE_NAME)\n# Set up the logger with FileHandler\ndef setup_logger(name=\"my_logger\"):\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.DEBUG)\n    if not logger.handlers:\n        # Attach FileHandler to send logs to a file\n        handler = logging.FileHandler(LOG_FILE_PATH)\n        handler.setLevel(logging.DEBUG)\n        # Define the log message format",
        "detail": "chatbot.actions.logger_fun",
        "documentation": {}
    },
    {
        "label": "preprocess_and_save_documents",
        "kind": 2,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "def preprocess_and_save_documents(directory_path: str, chunk_size: int = 1024, chunk_overlap: int = 50) -> None:\n    try:\n        if not os.path.exists(directory_path):\n            logger.error(f\"❌ Directory path '{directory_path}' does not exist.\")\n            return\n        if not os.listdir(directory_path):\n            logger.warning(f\"⚠️ Directory '{directory_path}' is empty.\")\n            return\n        # Step 1: Load documents\n        documents, failed_pdfs, file_chunk_map = load_documents(directory_path)",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "load_documents",
        "kind": 2,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "def load_documents(directory_path: str):\n    from langchain.schema import Document\n    documents = []\n    failed_pdfs = []\n    file_chunk_map = {}\n    for root, _, files in os.walk(directory_path):\n        files = [f for f in files if not f.startswith('.')]\n        for file_name in files:\n            path = os.path.join(root, file_name)\n            ext = os.path.splitext(file_name)[1].lower()",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "get_loader",
        "kind": 2,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "def get_loader(file_extension: str, file_path: str):\n    try:\n        if file_extension == \".pdf\":\n            try:\n                return PyPDFLoader(file_path)\n            except Exception:\n                logger.warning(f\"🔄 PyPDFLoader failed for {file_path}. Using UnstructuredPDFLoader.\")\n                return UnstructuredPDFLoader(file_path, mode=\"elements\")\n        else:\n            loaders = {",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "extract_date_from_filename",
        "kind": 2,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "def extract_date_from_filename(filename: str) -> str:\n    match = re.search(r'(\\d{4}-\\d{2}-\\d{2})', filename)\n    return match.group(1) if match else \"Nao applicable\"\ndef split_documents(documents: list, chunk_size: int = 1024, chunk_overlap: int = 50) -> list:\n    from langchain.schema import Document\n    splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)\n    all_chunks = []\n    for doc in documents:\n        chunks = splitter.split_documents([doc])\n        all_chunks.extend(chunks)",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "split_documents",
        "kind": 2,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "def split_documents(documents: list, chunk_size: int = 1024, chunk_overlap: int = 50) -> list:\n    from langchain.schema import Document\n    splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)\n    all_chunks = []\n    for doc in documents:\n        chunks = splitter.split_documents([doc])\n        all_chunks.extend(chunks)\n    return all_chunks\ndef load_or_create_faiss_index(texts: list, normalized_embeddings: list, metadata_list: list, embeddings) -> FAISS:\n    text_embedding_pairs = list(zip(texts, normalized_embeddings))",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "load_or_create_faiss_index",
        "kind": 2,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "def load_or_create_faiss_index(texts: list, normalized_embeddings: list, metadata_list: list, embeddings) -> FAISS:\n    text_embedding_pairs = list(zip(texts, normalized_embeddings))\n    if os.path.exists(FAISS_INDEX_FILE):\n        try:\n            vectordb = FAISS.load_local(FAISS_INDEX_FILE, embeddings, allow_dangerous_deserialization=True)\n            index_dim = vectordb.index.d\n            embedding_dim = len(embeddings.embed_query(\"test\"))\n            if index_dim != embedding_dim:\n                logger.warning(f\"⚠️ FAISS index dimension mismatch: Expected {embedding_dim}, Found {index_dim}. Rebuilding.\")\n                os.remove(FAISS_INDEX_FILE)",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "openai_api_key",
        "kind": 5,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "openai_api_key = os.getenv(\"OPENAI_API_KEY\")\nif not openai_api_key:\n    raise EnvironmentError(\"OPENAI_API_KEY not found in environment variables.\")\nos.environ[\"OPENAI_API_KEY\"] = openai_api_key\n# Logging setup\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n# Constants\nFAISS_INDEX_FILE = \"faiss_index\"",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "os.environ[\"OPENAI_API_KEY\"]",
        "kind": 5,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "os.environ[\"OPENAI_API_KEY\"] = openai_api_key\n# Logging setup\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n# Constants\nFAISS_INDEX_FILE = \"faiss_index\"\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n# -------------------------------------------------------------------\n# 📌 Main Preprocessing Function",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\n# Constants\nFAISS_INDEX_FILE = \"faiss_index\"\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n# -------------------------------------------------------------------\n# 📌 Main Preprocessing Function\n# -------------------------------------------------------------------\ndef preprocess_and_save_documents(directory_path: str, chunk_size: int = 1024, chunk_overlap: int = 50) -> None:",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "FAISS_INDEX_FILE",
        "kind": 5,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "FAISS_INDEX_FILE = \"faiss_index\"\nEMBEDDING_MODEL = \"text-embedding-3-large\"\n# -------------------------------------------------------------------\n# 📌 Main Preprocessing Function\n# -------------------------------------------------------------------\ndef preprocess_and_save_documents(directory_path: str, chunk_size: int = 1024, chunk_overlap: int = 50) -> None:\n    try:\n        if not os.path.exists(directory_path):\n            logger.error(f\"❌ Directory path '{directory_path}' does not exist.\")\n            return",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_MODEL",
        "kind": 5,
        "importPath": "chatbot.actions.preprocess_documents",
        "description": "chatbot.actions.preprocess_documents",
        "peekOfCode": "EMBEDDING_MODEL = \"text-embedding-3-large\"\n# -------------------------------------------------------------------\n# 📌 Main Preprocessing Function\n# -------------------------------------------------------------------\ndef preprocess_and_save_documents(directory_path: str, chunk_size: int = 1024, chunk_overlap: int = 50) -> None:\n    try:\n        if not os.path.exists(directory_path):\n            logger.error(f\"❌ Directory path '{directory_path}' does not exist.\")\n            return\n        if not os.listdir(directory_path):",
        "detail": "chatbot.actions.preprocess_documents",
        "documentation": {}
    },
    {
        "label": "load_faq",
        "kind": 2,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "def load_faq(faq_path: str):\n    \"\"\"Loads FAQ data from an Excel/CSV file and embeds questions.\"\"\"\n    logger.info(f\"Loading FAQ data from: {faq_path}\")\n    try:\n        if faq_path.endswith(\".xlsx\") or faq_path.endswith(\".xls\"):\n            df = pd.read_excel(faq_path)\n        else:\n            with open(faq_path, \"rb\") as f:\n                result = chardet.detect(f.read(100000))\n            df = pd.read_csv(faq_path, encoding=result[\"encoding\"], on_bad_lines='skip')",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "parse_publication_date",
        "kind": 2,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "def parse_publication_date(date_str: str):\n    \"\"\"\n    Attempts to convert a 'YYYY-MM-DD' string into a datetime object.\n    If 'Nao applicable' or any parsing error, returns None,\n    so we can still handle it gracefully in logs and sorting.\n    \"\"\"\n    if not date_str or date_str.lower() == \"nao applicable\":\n        return None\n    try:\n        return datetime.strptime(date_str, \"%Y-%m-%d\")",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "rag_query_pipeline",
        "kind": 2,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "def rag_query_pipeline(query: str):\n    \"\"\"\n    1) Checks if the user query matches an FAQ entry.\n    2) If not, runs a FAISS similarity search to retrieve top chunks.\n    3) Re-ranks those chunks by publication_date (most recent first).\n    4) Constructs a final prompt and calls the LLM (GPT-4o).\n    \"\"\"\n    global faq_questions, faq_answers, faq_embeddings, vectordb\n    # Step A: Load FAQ data on first call (if not already in memory)\n    if not faq_questions:",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "openai_api_key",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "openai_api_key = os.getenv(\"OPENAI_API_KEY\")\nif not openai_api_key:\n    raise EnvironmentError(\"OPENAI_API_KEY not found in environment variables.\")\n# Logger configuration\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nlogging.basicConfig(\n    level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s'\n)\n# Constants",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\nlogging.basicConfig(\n    level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s'\n)\n# Constants\nFAISS_INDEX_FILE = \"/app/actions/faiss_index\"\nFAQ_FILE = \"/app/actions/FAQ_Chatbot.xlsx\"\nEMBEDDING_MODEL = \"text-embedding-3-large\"\nLLM_MODEL = \"gpt-4o\"",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "FAISS_INDEX_FILE",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "FAISS_INDEX_FILE = \"/app/actions/faiss_index\"\nFAQ_FILE = \"/app/actions/FAQ_Chatbot.xlsx\"\nEMBEDDING_MODEL = \"text-embedding-3-large\"\nLLM_MODEL = \"gpt-4o\"\n# Initialize embedding model\nembedding_model = OpenAIEmbeddings(model=EMBEDDING_MODEL)\n# Globals\nfaq_questions, faq_answers, faq_embeddings = [], [], []\nvectordb = None\n# -------------------------------------------------------------------",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "FAQ_FILE",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "FAQ_FILE = \"/app/actions/FAQ_Chatbot.xlsx\"\nEMBEDDING_MODEL = \"text-embedding-3-large\"\nLLM_MODEL = \"gpt-4o\"\n# Initialize embedding model\nembedding_model = OpenAIEmbeddings(model=EMBEDDING_MODEL)\n# Globals\nfaq_questions, faq_answers, faq_embeddings = [], [], []\nvectordb = None\n# -------------------------------------------------------------------\n# 📘 Function: Load FAQ Data",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "EMBEDDING_MODEL",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "EMBEDDING_MODEL = \"text-embedding-3-large\"\nLLM_MODEL = \"gpt-4o\"\n# Initialize embedding model\nembedding_model = OpenAIEmbeddings(model=EMBEDDING_MODEL)\n# Globals\nfaq_questions, faq_answers, faq_embeddings = [], [], []\nvectordb = None\n# -------------------------------------------------------------------\n# 📘 Function: Load FAQ Data\n# -------------------------------------------------------------------",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "LLM_MODEL",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "LLM_MODEL = \"gpt-4o\"\n# Initialize embedding model\nembedding_model = OpenAIEmbeddings(model=EMBEDDING_MODEL)\n# Globals\nfaq_questions, faq_answers, faq_embeddings = [], [], []\nvectordb = None\n# -------------------------------------------------------------------\n# 📘 Function: Load FAQ Data\n# -------------------------------------------------------------------\ndef load_faq(faq_path: str):",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "embedding_model",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "embedding_model = OpenAIEmbeddings(model=EMBEDDING_MODEL)\n# Globals\nfaq_questions, faq_answers, faq_embeddings = [], [], []\nvectordb = None\n# -------------------------------------------------------------------\n# 📘 Function: Load FAQ Data\n# -------------------------------------------------------------------\ndef load_faq(faq_path: str):\n    \"\"\"Loads FAQ data from an Excel/CSV file and embeds questions.\"\"\"\n    logger.info(f\"Loading FAQ data from: {faq_path}\")",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    },
    {
        "label": "vectordb",
        "kind": 5,
        "importPath": "chatbot.actions.rag_app",
        "description": "chatbot.actions.rag_app",
        "peekOfCode": "vectordb = None\n# -------------------------------------------------------------------\n# 📘 Function: Load FAQ Data\n# -------------------------------------------------------------------\ndef load_faq(faq_path: str):\n    \"\"\"Loads FAQ data from an Excel/CSV file and embeds questions.\"\"\"\n    logger.info(f\"Loading FAQ data from: {faq_path}\")\n    try:\n        if faq_path.endswith(\".xlsx\") or faq_path.endswith(\".xls\"):\n            df = pd.read_excel(faq_path)",
        "detail": "chatbot.actions.rag_app",
        "documentation": {}
    }
]